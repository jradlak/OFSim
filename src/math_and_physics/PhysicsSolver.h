#pragma once

#define GLM_ENABLE_EXPERIMENTAL

#include "glm/ext.hpp"
#include "glm/gtx/string_cast.hpp"

#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/euler_angles.hpp> 

#include "Geometry.h"
#include "../world/CelestialBody.h"
#include "../world/Rocket.h"

namespace ofsim_math_and_physics
{
	/*
	The PhysicsSolver class is a part of a simulation engine, specifically designed to handle the physics 
	calculations related to a rocket's movement and interaction with celestial bodies.
	Here's a brief overview of its responsibilities:

	State Changes: It provides methods to change the state of the rocket, such as changeAltitudeOrientation, 
	updateKeyPressed, updateThrustMagnitude, rotateVectors, rotateRocket, and resetForces. 
	These methods alter the rocket's position, orientation, thrust, and other physical properties.

	Force Calculations: The calculateForces method calculates the net force acting on the rocket
	at a given time interval, considering factors like gravity, thrust, and possibly drag.

	Trajectory Prediction: The predictTrajectory method  calculates and stores 
	the predicted path of the rocket based on its current state and the forces acting on it.

	Getters: The class provides several getter methods to access properties like altitude, 
	thrust magnitude, atmosphere color, drag force, delta position, and trajectory predictions.

	Reset: The reset method resets the state of the PhysicsSolver to its initial state.

	The class uses the GLM (OpenGL Mathematics) library for vector and matrix math operations, 
	which are essential in 3D physics calculations.
	*/
	class PhysicsSolver
	{
	public:
		PhysicsSolver(RocketPhysicalProperties _rocketProperties, i32 _MS_PER_UPDATE);

		// change state methods:

		// change the initial orientation of the rocket to face towards the planet 
		void changeInitialAltitudeOrientation(
			CelestialBodyType _celestialBodyType, 
			f64 _celestialBodySize,
			dvec3 _towards);

		u64 calculateForces(u64 timeInterval);

	
		// update the thrust vector magnitude (power generated by the rocket's motor)
		// used in the API by the orbital programs written by the usersto control the rocket's thrust
		void updateThrustMagnitude(f64 newMagintude);

		// similar to above: rotate the rocket's orientation (and by design thrust verctor) by a given angle
		void rotateRocket(dvec3 deltaRotation);

		// Computes the trajectory prediction of the rocket based on its current state and the forces acting on it.
		void predictTrajectory(u64 elapsedTime);

		void resetForces() { forces.clear(); }
		void reset();

		//  simple properties getters:
		f64 getAltitude() { return altitude; }
		f64 getThrustMagnitude() { return thrustMagnitude; }	
		std::vector<f32> atmosphereRgb() { return { r, g, b }; }
		f64 getAtmosphereDragForceMagnitude() { return altitude > 98.0 ? 0.0 : atmosphereDragForceMagnitude; }
		dvec3 getDeltaPosition() { return deltaP; }
		std::vector<f64> getTrajectoryPredictionX() { return trajectoryPredictionX; }
		std::vector<f64> getTrajectoryPredictionY() { return trajectoryPredictionY; }
		std::vector<f64> getTrajectoryPredictionZ() { return trajectoryPredictionZ; }

		~PhysicsSolver() {}

	private:

		const f32 orr { 0.25 }, og { 0.55 }, ob { 0.75 };

		//earth's atmosphere gradient color:
		f32 r { 0.25 }, g { 0.55 }, b { 0.75 };
		
		// PRIVATE VARIABLES:

		std::vector<dvec3> forces;

		CelestialBodyType altitudeOrientation;
		//Rocket& rocket;
		RocketPhysicalProperties rocketProperties;
		
		f64 altitude;
		f64 celestialBodySize;
		f64 atmosphereDragForceMagnitude { 0.0 };

		f64 GConst = -0.00981;

		int MS_PER_UPDATE;

		dvec3 thrustVector;
		f64 thrustMagnitude;

		bool thrustCutOff;

		i32 lastKeyPressed;
		bool mustRecalculateVectors = false;

		dvec3 towards;
		dvec3 lastPos;

		dvec3 initialTowards;

		dvec3 deltaP;

		f64 theta = 30.0; // TODO: find better initial vaules
		f64 phi = 30.0;

		std::vector<f64> trajectoryPredictionX;
		std::vector<f64> trajectoryPredictionY;
		std::vector<f64> trajectoryPredictionZ;
		std::vector<f64> velocityMagnitude;

		// PRIVATE METHODS:

		void updatePhysics(f64 deltaTime);
		void addForce(vec3 force) { forces.push_back(force); }

		void rotateVectors(dvec3 newRotation, dvec3 deltaRotation);

		void calculateAtmosphereGradient();
		void calculateAtmosphericDragForce();
		
		f64 calculateAltitude();
		
		dvec3 celestialBodyCenter(f64 bodySize) { return dvec3(0.0, 0.0, 0.0); }	
	};
}