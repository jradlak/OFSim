#pragma once

#define GLM_ENABLE_EXPERIMENTAL

#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/euler_angles.hpp> 

#include "../world/CelestialBody.h"
#include "../world/Rocket.h"
#include "../world/SolarSystemConstants.h"

namespace ofsim_math_and_physics
{
    constexpr f32 upper_atmosphere_boundary { 98.0f };
    constexpr f32 dense_atmosphere_boundary { 20.0f };

    // initial rocket and camera rotation angles:
    constexpr f64 theta{ 30.0 };
    constexpr f64 phi{ 60.0 };

	/*
	The PhysicsSolver class is a part of a simulation engine, specifically designed to handle the physics 
	calculations related to a rocket's movement and interaction with celestial bodies.
	Here's a brief overview of its responsibilities:

	State Changes: It provides methods to change the state of the rocket, such as changeAltitudeOrientation, 
	updateKeyPressed, updateThrustMagnitude, rotateRocket, and resetForces. 
	These methods alter the rocket's position, orientation, thrust, and other physical properties.

	Force Calculations: The calculateForces method calculates the net force acting on the rocket
	at a given time interval, considering factors like gravity, thrust, and possibly drag.

	Trajectory Prediction: The predictTrajectory method  calculates and stores 
	the predicted path of the rocket based on its current state and the forces acting on it.

	Getters: The class provides several getter methods to access properties like altitude, 
	thrust magnitude, atmosphere color, drag force, delta position, and trajectory predictions.

	Reset: The reset method resets the state of the PhysicsSolver to its initial state.

	The class uses the GLM (OpenGL Mathematics) library for vector and matrix math operations, 
	which are essential in 3D physics calculations.
	*/
	class PhysicsSolver
	{
	public:
		PhysicsSolver(
            ofsim_world::RocketPhysicalProperties& _rocketProperties,
			CelestialBodyType _celestialBodyType,
			f64 _celestialBodySize,
			i32 _MS_PER_UPDATE);

		// change state methods:

		// change the initial orientation of the rocket to face towards the planet 
        void establishInitialOrientation(dvec3 rocketInitialPosition);

		u64 calculateForces(u64 timeInterval);

		// update the thrust vector magnitude (power generated by the rocket's motor)
		// used in the API by the orbital programs written by the usersto control the rocket's thrust
		void updateThrustMagnitude(f64 newMagintude);

		// similar to above: rotate the rocket's orientation (and by design thrust verctor) by a given angle
		void rotateRocket(dvec3 deltaRotation) { rotateRocketAndThrust(deltaRotation); }
				
		// Computes the trajectory prediction of the rocket based on its current state and the forces acting on it.
		void predictTrajectory(u64 elapsedTime);

		void resetForces() { forces.clear(); }
		void reset();

		//  simple properties getters:
		f64 getAltitude() { return altitude; }
		f64 getThrustMagnitude() { return thrustMagnitude; }	
        dvec3 getThrustVector() { return thrustVector; }
		std::vector<f32> atmosphereRgb() { return { r, g, b }; }
		f64 getAtmosphereDragForceMagnitude() { return altitude > max_altitude ? 0.0 : atmosphereDragForceMagnitude; }
		dvec3 getDeltaPosition() { return deltaP; }
		std::vector<f64> getTrajectoryPredictionX() { return trajectoryPredictionX; }
		std::vector<f64> getTrajectoryPredictionY() { return trajectoryPredictionY; }
        std::vector<f64> getTrajectoryPredictionZ() { return trajectoryPredictionZ; }

	private:
		// constants:		
		const f32 orr{ 0.25 }, og{ 0.55 }, ob{ 0.75 };	// earth's atmosphere gradient color oryginal values		
		const f32 min_altitude = 0.2; // from threre we start to calculate physics
		const f32 max_altitude = 98.0; // upper bounday of the atmosphere
        const f32 min_mass = 2.0; // mass of the rocket without the fuel
		const f32 min_thrust = 0.0001; // thrust magnitude when the engine is off
        const u32 prediction_steps = 2048; // number of steps in the trajectory prediction

		//earth's atmosphere gradient color:
		f32 r { 0.25 }, g { 0.55 }, b { 0.75 };		

		// PRIVATE VARIABLES:

		std::vector<dvec3> forces;

		CelestialBodyType celestialBodyType;
        ofsim_world::RocketPhysicalProperties& rocketProperties;
		
		f64 altitude;
		f64 celestialBodySize;
		f64 atmosphereDragForceMagnitude { 0.0 };

		int ms_per_update;

		dvec3 thrustVector;
		f64 thrustMagnitude;
		bool thrustCutOff;	
		
		dvec3 lastPos;	
		dvec3 deltaP;

		// trajectory prediction:
		std::vector<f64> trajectoryPredictionX;
		std::vector<f64> trajectoryPredictionY;
		std::vector<f64> trajectoryPredictionZ;
		std::vector<f64> velocityMagnitude;

		// PRIVATE METHODS:

		void updatePhysics(f64 deltaTime);
		void addForce(vec3 force) { forces.push_back(force); }

		// rotate the rocket's orientation by a given angle
		// as well as the thrust vector
		void rotateRocketAndThrust(dvec3 deltaRotation);

		// atmosphere gradient simulation
		// taking the altitude into account and gradually changing the atmosphere color
		void calculateAtmosphereGradient();
		
		// calculate the atmospheric drag force acting on the rocket
		// based on the altitude and the rocket's velocity
		void calculateAtmosphericDragForce();
		
		f64 calculateAltitude();
		
		dvec3 celestialBodyCenter(f64 bodySize) { return SolarSystemConstants::earthPos; }
	};
}
